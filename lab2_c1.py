# -*- coding: utf-8 -*-
"""lab2_c1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YAxI-yxaVX7YqKHbA_Gy1Uf7UPJKtQhK

# initialize
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
import torchvision
import torchvision.transforms as transforms
from resnet import ResNet18
import numpy as np
import random
import os
import argparse
import time

parse = argparse.ArgumentParser(description = 'Lab2')
parse.add_argument('--lr', default = 0.1, type = float, help = 'learning rate')
parse.add_argument('--opt', default = 'sgd', type = str, help = 'optimizer')
parse.add_argument('--cuda', default = 'cpu', type = str, help = 'cuda')
parse.add_argument('--num_workers', default = 0, type = int, help = 'num_workers')
args = parse.parse_args()

lr = args.lr
opt = args.opt
num_workers = args.num_workers
cuda = args.cuda
print(lr, opt, num_workers,cuda)

"""# Load data"""

trainsform_train = transforms.Compose([
    transforms.RandomCrop(32, padding = 4),
    transforms.RandomHorizontalFlip(p=0.5),
    transforms.ToTensor(),
    transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010))
])

trainsform_test = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010))
])

train_set = torchvision.datasets.CIFAR10(root = './data', train=True, download=True, transform=trainsform_train)
test_set = torchvision.datasets.CIFAR10(root = './data', train=False, download=True, transform=trainsform_test)
train_loader = torch.utils.data.DataLoader(train_set, batch_size = 128,shuffle = True, num_workers = num_workers)
test_loader = torch.utils.data.DataLoader(test_set, batch_size = 100, shuffle = True, num_workers = num_workers)

"""# Criterion and Optimizer"""

if cuda == 'cpu':
    device = 'cpu'
elif cuda == 'gpu':
    device = 'cuda' if torch.cuda.is_available() else 'cpu'

print("device:" , device)

net = ResNet18().to(device)

from torchsummary import summary
summary(net, (3,32,32))

criterion = nn.CrossEntropyLoss()
if opt == 'sgd':
    optimizer = optim.SGD(net.parameters(), lr=lr, momentum=0.9, weight_decay=5e-4)
elif opt == 'adam':
    optimizer = optim.Adam(net.parameters(), lr=lr, weight_decay=5e-4)

"""# Train and Test

## Train
"""

best_train_acc = 0

def train(epoch):
    net.train()
    train_loss = 0
    correct = 0
    total = 0
    for batch_idx, (inputs, targets) in enumerate(train_loader):
        inputs, targets = inputs.to(device), targets.to(device)
        optimizer.zero_grad()
        outputs = net(inputs)
        loss = criterion(outputs, targets)
        loss.backward()
        optimizer.step()

        train_loss += loss.item()
        _, predicted = outputs.max(1)
        total += targets.size(0)
        correct += predicted.eq(targets).sum().item()
        # print('Epoch: %d | Batch: %d | Loss: %.3f | Acc: %.3f'% (epoch, batch_idx, train_loss/(batch_idx+1), 100.*correct/total))
    print('[Train]: Epoch: %d | Loss: %.3f | Acc: %.3f%%'% (epoch+1, train_loss/(100), 100.*correct/total))
    
    acc = 100.*correct/total
    if acc > best_train_acc:
        print('Saving Epoch ',epoch+1)
        state = {
            'net': net.state_dict(),
            'acc': acc,
            'epoch': epoch+1,
        }
        if not os.path.isdir('checkpoint'):
            os.mkdir('checkpoint')
        torch.save(state, './checkpoint/best_train.pth')
        best_acc = acc

for epoch in range(0, 5):
    train(epoch)

"""## Test"""

net = ResNet18().to(device)
load_net = torch.load('./checkpoint/best_train.pth')
net.load_state_dict(load_net['net'])

best_test_acc = 0

def test(epoch):
    net.eval()
    test_loss = 0
    correct = 0
    total = 0
    with torch.no_grad():
        for batch_idx, (inputs, targets) in enumerate(test_loader):
            inputs, targets = inputs.to(device), targets.to(device)
            outputs = net(inputs)
            loss = criterion(outputs, targets)

            test_loss += loss.item()
            _, predicted = outputs.max(1)
            total += targets.size(0)
            correct += predicted.eq(targets).sum().item()
        print('[Test]: Epoch: %d | Loss: %.3f | Acc: %.3f%%'% (epoch, test_loss/(100), 100.*correct/total))

test(1)

